// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CocoaLumberjack
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import CocoaLumberjack
import Combine
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension CocoaLumberjack.DDLogFlag {
  public static func from(_ logLevel: CocoaLumberjack.DDLogLevel) -> CocoaLumberjack.DDLogFlag
  public init(_ logLevel: CocoaLumberjack.DDLogLevel)
  public func toLogLevel() -> CocoaLumberjack.DDLogLevel
}
public var dynamicLogLevel: CocoaLumberjack.DDLogLevel
@inlinable public func resetDynamicLogLevel() {
    dynamicLogLevel = .all
}
@available(*, deprecated, renamed: "dynamicLogLevel", message: "Please use dynamicLogLevel")
public var defaultDebugLevel: CocoaLumberjack.DDLogLevel {
  get
  set
}
@available(*, deprecated, renamed: "resetDynamicLogLevel", message: "Please use resetDynamicLogLevel")
public func resetDefaultDebugLevel()
public var asyncLoggingEnabled: Swift.Bool
@frozen public struct DDLogMessageFormat : Swift.ExpressibleByStringInterpolation {
  public typealias StringLiteralType = Swift.String
  @usableFromInline
  internal struct Storage {
    @usableFromInline
    internal var format: Swift.String
    @usableFromInline
    internal var args: Swift.Array<any Swift.CVarArg>
    @usableFromInline
    internal init(format: Swift.String, args: Swift.Array<any Swift.CVarArg>)
  }
  @frozen public struct StringInterpolation : Swift.StringInterpolationProtocol {
    @usableFromInline
    internal var storage: CocoaLumberjack.DDLogMessageFormat.Storage
    @inlinable public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int) {
            var format = String()
            format.reserveCapacity(literalCapacity)
            var args = Array<CVarArg>()
            args.reserveCapacity(interpolationCount)
            storage = .init(format: format, args: args)
        }
    @inlinable public mutating func appendLiteral(_ literal: CocoaLumberjack.DDLogMessageFormat.StringLiteralType) {
            storage.format.append(literal)
        }
    @inlinable public mutating func appendInterpolation<S>(_ string: S) where S : Swift.StringProtocol {
            storage.format.append("%@")
            storage.args.append(String(string))
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.Int8) {
            storage.format.append("%c")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.UInt8) {
            storage.format.append("%c")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.Int16) {
            storage.format.append("%i")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.UInt16) {
            storage.format.append("%u")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.Int32) {
            storage.format.append("%li")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.UInt32) {
            storage.format.append("%lu")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.Int64) {
            storage.format.append("%lli")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.UInt64) {
            storage.format.append("%llu")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.Int) {
            storage.format.append("%lli")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ int: Swift.UInt) {
            storage.format.append("%llu")
            storage.args.append(int)
        }
    @inlinable public mutating func appendInterpolation(_ flt: Swift.Float) {
            storage.format.append("%f")
            storage.args.append(flt)
        }
    @inlinable public mutating func appendInterpolation(_ dbl: Swift.Double) {
            storage.format.append("%lf")
            storage.args.append(dbl)
        }
    @inlinable public mutating func appendInterpolation(_ bool: Swift.Bool) {
            storage.format.append("%i") // bools are printed as ints
            storage.args.append(bool)
        }
    @inlinable public mutating func appendInterpolation<Convertible>(_ c: Convertible) where Convertible : Foundation.ReferenceConvertible {
            storage.format.append("%@")
            // This should be safe, sine the compiler should convert it to the reference.
            storage.args.append(c as? CVarArg ?? c as! Convertible.ReferenceType)
        }
    @inlinable public mutating func appendInterpolation<Obj>(_ o: Obj) where Obj : ObjectiveC.NSObject {
            storage.format.append("%@")
            storage.args.append(o)
        }
    @_disfavoredOverload public mutating func appendInterpolation(_ any: Any)
    public typealias StringLiteralType = CocoaLumberjack.DDLogMessageFormat.StringLiteralType
  }
  @usableFromInline
  internal let storage: CocoaLumberjack.DDLogMessageFormat.Storage
  @inlinable internal var format: Swift.String {
    get { storage.format }
  }
  @inlinable internal var args: Swift.Array<any Swift.CVarArg> {
    get { storage.args }
  }
  @inlinable internal var formatted: Swift.String {
    get {
        String(format: storage.format, arguments: storage.args)
    }
  }
  @inlinable public init(stringLiteral value: CocoaLumberjack.DDLogMessageFormat.StringLiteralType) {
        storage = .init(format: value, args: [])
    }
  @inlinable public init(stringInterpolation: CocoaLumberjack.DDLogMessageFormat.StringInterpolation) {
        storage = stringInterpolation.storage
    }
  @inlinable internal init(_formattedMessage: Swift.String) {
        storage = .init(format: _formattedMessage, args: [])
    }
  public typealias ExtendedGraphemeClusterLiteralType = CocoaLumberjack.DDLogMessageFormat.StringLiteralType
  public typealias UnicodeScalarLiteralType = CocoaLumberjack.DDLogMessageFormat.StringLiteralType
}
extension CocoaLumberjack.DDLogMessage {
  @inlinable convenience public init(_ format: CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel, flag: CocoaLumberjack.DDLogFlag, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, timestamp: Foundation.Date? = nil) {
        self.init(format: format.format,
                  formatted: format.formatted,
                  level: level,
                  flag: flag,
                  context: context,
                  file: String(describing: file),
                  function: String(describing: function),
                  line: line,
                  tag: tag,
                  options: [.dontCopyMessage],
                  timestamp: timestamp)
    }
}
@inlinable public func _DDLogMessage(_ messageFormat: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel, flag: CocoaLumberjack.DDLogFlag, context: Swift.Int, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, tag: Any?, asynchronous: Swift.Bool, ddlog: CocoaLumberjack.DDLog) {
    // The `dynamicLogLevel` will always be checked here (instead of being passed in).
    // We cannot "mix" it with the `DDDefaultLogLevel`, because otherwise the compiler won't strip strings that are not logged.
    if level.rawValue & flag.rawValue != 0 && dynamicLogLevel.rawValue & flag.rawValue != 0 {
        let logMessage = DDLogMessage(messageFormat(),
                                      level: level,
                                      flag: flag,
                                      context: context,
                                      file: file,
                                      function: function,
                                      line: line,
                                      tag: tag)
        ddlog.log(asynchronous: asynchronous, message: logMessage)
    }
}
@inlinable public func DDLogDebug(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .debug,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@inlinable public func DDLogInfo(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .info,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@inlinable public func DDLogWarn(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .warning,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@inlinable public func DDLogVerbose(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .verbose,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@inlinable public func DDLogError(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .error,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func _DDLogMessage(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel, flag: CocoaLumberjack.DDLogFlag, context: Swift.Int, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, tag: Any?, asynchronous: Swift.Bool, ddlog: CocoaLumberjack.DDLog) {
    // This will lead to `messageFormat` and `message` being equal on DDLogMessage,
    // which is what the legacy initializer of DDLogMessage does as well.
    _DDLogMessage(.init(_formattedMessage: String(describing: message())),
                  level: level,
                  flag: flag,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: asynchronous,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func DDLogDebug(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .debug,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func DDLogInfo(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .info,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func DDLogWarn(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .warning,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func DDLogVerbose(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = asyncLoggingEnabled, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .verbose,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
@available(*, deprecated, message: "Use an interpolated DDLogMessageFormat instead")
@inlinable @_disfavoredOverload public func DDLogError(_ message: @autoclosure () -> Any, level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = .sharedInstance) {
    _DDLogMessage(message(),
                  level: level,
                  flag: .error,
                  context: context,
                  file: file,
                  function: function,
                  line: line,
                  tag: tag,
                  asynchronous: async,
                  ddlog: ddlog)
}
public func currentFileName(_ fileName: Swift.StaticString = #file) -> Swift.String
@available(*, deprecated, renamed: "currentFileName", message: "Please use currentFileName")
public func CurrentFileName(_ fileName: Swift.StaticString = #file) -> Swift.String
@inlinable public func DDAssert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat = "", level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = DDLog.sharedInstance) {
    if !condition() {
        DDLogError(message(),
                   level: level,
                   context: context,
                   file: file,
                   function: function,
                   line: line,
                   tag: tag,
                   asynchronous: async,
                   ddlog: ddlog)
        Swift.assertionFailure(message().formatted, file: file, line: line)
    }
}
@inlinable public func DDAssertionFailure(_ message: @autoclosure () -> CocoaLumberjack.DDLogMessageFormat = "", level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = DDLog.sharedInstance) {
    DDLogError(message(),
               level: level,
               context: context,
               file: file,
               function: function,
               line: line,
               tag: tag,
               asynchronous: async,
               ddlog: ddlog)
    Swift.assertionFailure(message().formatted, file: file, line: line)
}
@available(*, deprecated, message: "Use an interpolated message.")
@inlinable public func DDAssert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = "", level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = DDLog.sharedInstance) {
    if !condition() {
        DDLogError(message(),
                   level: level,
                   context: context,
                   file: file,
                   function: function,
                   line: line,
                   tag: tag,
                   asynchronous: async,
                   ddlog: ddlog)
        Swift.assertionFailure(message(), file: file, line: line)
    }
}
@available(*, deprecated, message: "Use an interpolated message.")
@inlinable public func DDAssertionFailure(_ message: @autoclosure () -> Swift.String = "", level: CocoaLumberjack.DDLogLevel = DDDefaultLogLevel, context: Swift.Int = 0, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, tag: Any? = nil, asynchronous async: Swift.Bool = false, ddlog: CocoaLumberjack.DDLog = DDLog.sharedInstance) {
    DDLogError(message(),
               level: level,
               context: context,
               file: file,
               function: function,
               line: line,
               tag: tag,
               asynchronous: async,
               ddlog: ddlog)
    Swift.assertionFailure(message(), file: file, line: line)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CocoaLumberjack.DDLog {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct MessagePublisher : Combine.Publisher {
    public typealias Output = CocoaLumberjack.DDLogMessage
    public typealias Failure = Swift.Never
    public init(log: CocoaLumberjack.DDLog, with logLevel: CocoaLumberjack.DDLogLevel)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == CocoaLumberjack.DDLogMessage
  }
  public func messagePublisher(with logLevel: CocoaLumberjack.DDLogLevel = .all) -> CocoaLumberjack.DDLog.MessagePublisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output == CocoaLumberjack.DDLogMessage {
  public func formatted(with formatter: any CocoaLumberjack.DDLogFormatter) -> Combine.Publishers.CompactMap<Self, Swift.String>
}
