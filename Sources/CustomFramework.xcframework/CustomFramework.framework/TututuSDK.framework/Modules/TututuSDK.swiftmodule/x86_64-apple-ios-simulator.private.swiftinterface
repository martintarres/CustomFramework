// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TututuSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CocoaLumberjack
import CoreData
import CoreLocation
import CoreMotion
import CoreServices_iOS
import Foundation
import Repeat
import Swift
@_exported import TututuSDK
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension UIKit.UIDevice.BatteryState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct BreakEvent : Swift.Codable {
  public let severity: TututuSDK.BreakSeverity
  public let start: Foundation.TimeInterval
  public let stop: Foundation.TimeInterval
  public let acceleration: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum BreakSeverity : Swift.Codable {
  case low
  case medium
  case high
  case crash
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: TututuSDK.BreakSeverity, b: TututuSDK.BreakSeverity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TututuSDK.BreakSeverity : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc public enum DrivingStatus : Swift.Int16 {
  case notDriving = 0
  case maybeDriving = 1
  case isDriving = 2
  case stopDriving = 3
  case cancelDriving = 4
  case canceledDriving = 5
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
extension TututuSDK.DrivingStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc public enum EventsUploadStatus : Swift.Int16 {
  case notUploaded = 0
  case uploaded = 1
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
extension TututuSDK.EventsUploadStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct Location {
  public var timestamp: Foundation.Date
  public let latitude: Swift.Double
  public let longitude: Swift.Double
  public let speed: Swift.Double
  public let accuracy: Swift.Double
  public let course: Swift.Double
}
extension TututuSDK.Location : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension TututuSDK.Location : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension TututuSDK.Location : Swift.Equatable {
  public static func == (lhs: TututuSDK.Location, rhs: TututuSDK.Location) -> Swift.Bool
}
extension TututuSDK.Location {
  public func distance(from: TututuSDK.Location) -> Swift.Double
}
@_inheritsConvenienceInitializers @objc(ManagedDownloadSASTokenTask) public class ManagedDownloadSASTokenTask : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedDownloadSASTokenTask {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedDownloadSASTokenTask>
  @objc @NSManaged dynamic public var taskId: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var routeId: Swift.String {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(ManagedMonitorState) public class ManagedMonitorState : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedMonitorState {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedMonitorState>
  @objc @NSManaged dynamic public var lastMovingChange: Foundation.NSDate? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var lastStatusChange: Foundation.NSDate? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var status: TututuSDK.DrivingStatus {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(ManagedOngoingTrip) public class ManagedOngoingTrip : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedOngoingTrip {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedOngoingTrip>
  @objc @NSManaged dynamic public var guid: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var startDate: Foundation.NSDate? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var confirmed: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var manual: Swift.Bool {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(ManagedParkingLocation) public class ManagedParkingLocation : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedParkingLocation {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedParkingLocation>
  @objc @NSManaged dynamic public var latitude: Swift.Double {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var longitude: Swift.Double {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestamp: Foundation.NSDate? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(ManagedTripRoute) public class ManagedTripRoute : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedTripRoute {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedTripRoute>
  @objc @NSManaged dynamic public var guid: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var startDate: Foundation.NSDate? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var endDate: Foundation.NSDate? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var userId: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var vehicleId: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var subscriptionId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var uploadStatus: TututuSDK.UploadStatus {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var applicationId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var seqNumber: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var eventsUploadStatus: TututuSDK.EventsUploadStatus {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var isDiscarded: Swift.Bool {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(ManagedUploadTripRouteFileTask) public class ManagedUploadTripRouteFileTask : CoreData.NSManagedObject {
  @objc override dynamic public func awakeFromInsert()
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension TututuSDK.ManagedUploadTripRouteFileTask {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<TututuSDK.ManagedUploadTripRouteFileTask>
  @objc @NSManaged dynamic public var id: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var namespace: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var taskId: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var routeId: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var url: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var type: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var createdAt: Foundation.NSDate? {
    @objc get
    @objc set
  }
}
public struct Motion {
  public var timestamp: Swift.Double
  public var x: Swift.Double
  public var y: Swift.Double
  public var z: Swift.Double
  public var norm: Swift.Double {
    get
  }
}
extension TututuSDK.Motion {
  public var values: [Swift.String] {
    get
  }
  public static var keys: [Swift.String] {
    get
  }
}
public protocol MotionMonitorDelegate : AnyObject {
  func motionMonitorDidStart(_ motionMonitor: TututuSDK.MotionMonitor)
  func motionMonitorDidStop(_ motionMonitor: TututuSDK.MotionMonitor)
}
public protocol MotionResponder : AnyObject {
  func respondTo(motion: TututuSDK.Motion)
}
public class MotionMonitor {
  weak public var delegate: (any TututuSDK.MotionMonitorDelegate)?
  weak public var responder: (any TututuSDK.MotionResponder)?
  public init()
  public func start()
  public var isMonitoring: Swift.Bool {
    get
  }
  public func stop()
  @objc deinit
}
extension Foundation.NSNotification.Name {
  public static let tututuDidStart: Foundation.Notification.Name
  public static let tututuDidStop: Foundation.Notification.Name
  public static let tututuDidStartTrackingTrip: Foundation.Notification.Name
  public static let tututuDidStopTrackingTrip: Foundation.Notification.Name
  public static let tututuDidChangeActivity: Foundation.Notification.Name
  public static let tututuDidUpdateInputs: Foundation.Notification.Name
  public static let tututuDidBreak: Foundation.Notification.Name
  public static let tututuDidLowBatteryStop: Foundation.Notification.Name
  public static let tututuDidGoodBatteryStart: Foundation.Notification.Name
}
public struct OngoingTrip {
  public var guid: Swift.String?
  public var startDate: Foundation.Date?
  public var confirmed: Swift.Bool
  public var manual: Swift.Bool
}
extension TututuSDK.OngoingTrip : CoreServices_iOS.SinglePersistable {
  public typealias ManagedObject = TututuSDK.ManagedOngoingTrip
  public static var entityName: Swift.String
  public init(_ managedObject: TututuSDK.ManagedOngoingTrip)
  public func fill(_ managedObject: TututuSDK.ManagedOngoingTrip)
}
extension TututuSDK.TututuSDK {
  public struct Settings : Swift.Codable {
    public var drivingDetectionEnabled: Swift.Bool
    public var useCellularNetworks: Swift.Bool
    public var monitorBatteryStatus: Swift.Bool
    public var uploadOptions: TututuSDK.UploaderOptions
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct TripRoute {
  public var guid: Swift.String
  public var startDate: Foundation.Date
  public var endDate: Foundation.Date
  public let userId: Swift.Int
  public let vehicleId: Swift.Int
  public let subscriptionId: Swift.String
  public var uploadStatus: TututuSDK.UploadStatus
  public var applicationId: Swift.String
  public let seqNumber: Swift.Int
  public var eventsUploadStatus: TututuSDK.EventsUploadStatus
  public var isDiscarded: Swift.Bool
}
extension TututuSDK.TripRoute : CoreServices_iOS.MultiPersistable {
  public typealias ManagedObject = TututuSDK.ManagedTripRoute
  public static var entityName: Swift.String
  public static var idName: Swift.String
  public var id: Swift.String {
    get
  }
  public init(_ managedObject: TututuSDK.ManagedTripRoute)
  public func fill(_ managedObject: TututuSDK.ManagedTripRoute)
}
@_hasMissingDesignatedInitializers public class TututuSDK {
  public static let shared: TututuSDK.TututuSDK
  public var isTracking: Swift.Bool {
    get
  }
  public var settings: TututuSDK.TututuSDK.Settings {
    get
  }
  public func start(userInfo: TututuSDK.UserInfo, env: Swift.String, deploy: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Void, TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func stop()
  public func startTracking() throws
  public func stopTracking()
  public func updateSettings(_ settings: TututuSDK.TututuSDK.Settings, completionHandler: @escaping (Swift.Result<Swift.Void, TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func setSettings(_ settings: TututuSDK.TututuSDK.Settings)
  public func deleteRoute(tripRoute: TututuSDK.TripRoute, completionHandler: @escaping () -> Swift.Void)
  public func uploadRoute(for tripRoute: TututuSDK.TripRoute)
  public func uploadTelemetry(for tripRoute: TututuSDK.TripRoute)
  public func uploadEvents(for tripRoute: TututuSDK.TripRoute)
  public func updateSessionToken(token: Swift.String)
  public func fetchTripRoutes(completionHandler: @escaping (Swift.Result<[TututuSDK.TripRoute], TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func validate(tripRoute: TututuSDK.TripRoute, completionHandler: @escaping (Swift.Result<Swift.Bool, TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func fetchLocations(tripRoute: TututuSDK.TripRoute, completionHandler: @escaping (Swift.Result<[TututuSDK.Location], TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func fetchBreaks(tripRoute: TututuSDK.TripRoute, completionHandler: @escaping (Swift.Result<[TututuSDK.BreakEvent], TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func fetchTelemetryFile(tripRoute: TututuSDK.TripRoute, completionHandler: @escaping (Swift.Result<Foundation.URL, TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func export(tripRoute: TututuSDK.TripRoute, to url: Foundation.URL, completionHandler: @escaping (Swift.Result<Swift.Void, TututuSDK.TututuSDK.Error>) -> Swift.Void)
  public func performFetchWithCompletionHandler(_ completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  public func uploadRoutesIfNeeded()
  public func launch(launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?)
  public func setBackgroudSession(sessionId: Swift.String, completionHandler: @escaping () -> Swift.Void)
  @objc deinit
}
extension TututuSDK.TututuSDK {
  public enum Error : Swift.Error {
    case failedToCreateService
    case databaseError
    case missingLocationPermissions
    case missingLocationAccuracyPermissions
    case missingActivityPermissions
    case methodUnavailableWhileTrackingTrip
    case batteryLevelLow
    public static func == (a: TututuSDK.TututuSDK.Error, b: TututuSDK.TututuSDK.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TututuSDK.TututuSDK.Error : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct UploaderOptions : Swift.Codable {
  public let delay: Swift.Double
  public init(delay: Swift.Double)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc public enum UploadStatus : Swift.Int16 {
  case notUploaded = 0
  case tripUploaded = 1
  case telemetryUploaded = 2
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
extension TututuSDK.UploadStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct UserInfo {
  public init(userId: Swift.Int, vehicleId: Swift.Int, subscriptionId: Swift.String, applicationId: Swift.String)
}
extension TututuSDK.UserInfo : Swift.Equatable {
  public static func == (lhs: TututuSDK.UserInfo, rhs: TututuSDK.UserInfo) -> Swift.Bool
}
public struct Waypoint {
}
extension TututuSDK.Waypoint : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension TututuSDK.Waypoint : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension TututuSDK.BreakSeverity : Swift.Equatable {}
extension TututuSDK.BreakSeverity : Swift.Hashable {}
extension TututuSDK.DrivingStatus : Swift.Equatable {}
extension TututuSDK.DrivingStatus : Swift.Hashable {}
extension TututuSDK.DrivingStatus : Swift.RawRepresentable {}
extension TututuSDK.EventsUploadStatus : Swift.Equatable {}
extension TututuSDK.EventsUploadStatus : Swift.Hashable {}
extension TututuSDK.EventsUploadStatus : Swift.RawRepresentable {}
extension TututuSDK.TututuSDK.Error : Swift.Equatable {}
extension TututuSDK.TututuSDK.Error : Swift.Hashable {}
extension TututuSDK.UploadStatus : Swift.Equatable {}
extension TututuSDK.UploadStatus : Swift.Hashable {}
extension TututuSDK.UploadStatus : Swift.RawRepresentable {}
